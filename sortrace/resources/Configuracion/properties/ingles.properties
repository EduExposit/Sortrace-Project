#Titulo
titulo=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n
tituloSeleccion=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n [Selecci\u00f3n]
tituloInsercion=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n [Inserci\u00f3n]
tituloBurbujaBasico=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n [Burbuja b\u00e1sico]
tituloBurbujaOptimizado=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n [Burbuja optimizado]
tituloIncrementos=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n [Incrementos decrecientes]
tituloRapida=Sortrace - Sistema de visualizaci\u00f3n acumulativa en algoritmos de ordenaci\u00f3n [R\u00e1pida]

#Menu
menuArchivo=File
menuEjecucion=Execution
menuAlgoritmo=Select algorithm
menuConfiguracion=Settings
menuAyuda=Help

#Archivo
archivoIntroducirDatos=Introduce data...
archivoGeneradDatos=Generate random data...
archivoCargarDatos=Load data...
archivoModificarDatos=Change input data...
archivoAlmacenarFicheros=Save file...
archivoExportarImagen=Export image...
archivoExportarSecuencia=Export sequence of images...
archivoExportarAnimacion=Export animation...
archivoSalir=Exit

#Ejecucion
ejecucionPausa=Pause
ejecucionRetrocederComienzo=Go back to the beginning
ejecucionRetrocederIteracion=Go back to the beginning of the iteration
ejecucionRetrocederPaso=Go back one step
ejecucionRetrocederContinuo=Go back continuous
ejecucionAvanzarContinuo=Advance continuous
ejecucionAvanzarPaso=Advance one step forward
ejecucionAvanzarIteracion=Advance to the end of the iteration
ejecucionAvanzarFinal=Advance to the end
ejecucionAbandonarEjecucion=Abandonar ejecucion

#ALgoritmos
algoritmosTextoSeleccion=<html><p align=\"center\">Selection</p><p align=\"center\">sort</p></html>
algortimosToolSeleccion=Selection sort
algoritmosTextoInsercion=<html><p align=\"center\">Insertion</p><p align=\"center\">sort</p></html>
algortimosToolInsercion=Insertion sort
algoritmosTextoBurbujaBasica=<html><p align=\"center\">Basic bubble</p><p align=\"center\">sort</p></html>
algortimosToolBurbujaBasica=Basic bubble sort
algoritmosTextoBurbujaAvanzada=<html><p align=\"center\">Optimized bubble</p><p align=\"center\">sort</p></html>
algortimosToolBurbujaAvanzada=Optimized bubble sort
algoritmosTextoShell=<html><p align=\"center\">Shell</p><p align=\"center\">sort</p></html>
algortimosToolShell=Shell sort

#Configuracion
configuracionVisualizacion=Visualization...
configuracionIdioma=Language...
configuracionAnimacion=Animation...

#Ayuda
ayudaSortrace=Help of Sortrace...
ayudaSobreSortrace=About Sortrace

#FrameIntroducirDatos
introducirDatosTitulo=Introduce data
introducirDatosBotonAceptar=Accept
introducirDatosBotonCancelar=Cancel
introducirDatosEtiquetaTamano=Enter vector size
introducirDatosPosicion=Position
introducirDatosElemento=Element
introducirDatosEtiquetaEntrada=Enter vector input data
introducirDatosErrorMensajeFormato=The data entered is not valid: you must enter numbers
introducirDatosErrorTituloFormato=Format error
introducirDatosTituloExito=Success
introducirDatosMensajeExito=Success creating the vector

#FrameGenerarDatosAleatorios
generarDatosTitulo=Generate random data
generarDatosAtajo=Do you want to generate a completely random vector or customize some parameters?
generarDatosPersonalizar=Customize
generarDatosAleatorio=Random
generarDatosEtiquetaTamaño=Vector size
generarDatosEtiquetaIntervalo=Vector values range
generarDatosEtiquetaAviso=Vector elements must be between [-999 ... 999]
generarDatosOrden=Order
generarDatosOrdenAleatorio=Random
generarDatosOrdenCreciente=Ascending order
generarDatosOrdenDereciente=Descending order
generarDatosBotonAceptar=Accept
generarDatosBotonCancelar=Cancel
generarDatosLimitesMensaje=The lower limit entered must be less than the upper limit
generarDatosLimitesTitulo=Limits error
generarDatosLimiteInferiorMensaje=The lower limit cannot be less than -999
generarDatosLimiteInferiorTitulo=Lower limit error
generarDatosLimInfVacioMensaje=Default lower limit -999
generarDatosLimInfVacioTitulo=Lower limit empty
generarDatosLimiteSuperiorMensaje=The upper limit cannot be higher than 999
generarDatosLimiteSuperiorTitulo=Upper limit error
generarDatosLimSupVacioMensaje=Default upper limit 999
generarDatosLimSupVacioTitulo=Upper limit empty

#ModificarDatos
modificarDatosTitulo=Modify data

#PanelTeoria
teoriaTitulo=Theory
teoriaPaginaTeoria=Algorithm
teoriaPaginaCodigo=Code
teoriaSeleccion1=The direct selection algorithm performs a sequence of iterations, so that, in each iteration, the smallest element of the part of the vector is selected that is still disordered and is placed after the ordered part. \n To be specific, we can imagine that the vector is divided into two parts, a part already ordered located on the left and another still disordered located on the right. Initially the ordered left part is empty. In the figures, we separate both parts by a thick vertical bar. For example, let the following vector be: \n
teoriaSeleccion2=\nThe first iteration will select the smallest element from the unordered part (1) and swap it with the cell to the right of the ordered part (8). Since the algorithm must achieve this for a vector with any content, the smallest element is determined by comparing all the cells of the disordered part, from its extreme right to its extreme left. After this iteration, the ordered part already has one element and the disordered part, the rest. \n
teoriaSeleccion3=\nIn the next iteration, the next minor element (the 2) is re-determined by comparing the cells from the far right of the vector to separation with the ordered part. Once determined, it will be swapped with the item to the right of the ordered part (the 8). After this iteration, the ordered part already has two elements.\n
teoriaSeleccion4=\nThe process described will be repeated until a single element (8) remains in the disordered part, which will be greater than all the others and therefore it will not be necessary to carry out a last iteration because the complete vector will already be ordered.\n
teoriaSeleccion5=\nThe direct selection algorithm has a quadratic complexity. Its analysis is practically the same as that of the bubble since the loops are controlled by indices in a very similar way, varying only in other operations, which are of constant cost. Let n be the length of the vector. The algorithm's time function is equal to: \n
teoriaSeleccion6=\nNote that the inner loop contains a conditional statement. Being strict, we should perform an analysis of the algorithm distinguishing between best, worst and average case, since the body of the conditional instruction will be executed or not depending on the case. However, the number of iterations does not vary, so the time function for these cases varies by constant factors, but its quadratic order of complexity does not vary.
teoriaBurbujaBasica1=The bubble algorithm is so named because it performs a sequence of iterations, in such a way that, in each one, the smallest element of one part of the vector moves towards the other part, like a "bubble" that floats over the elements still messy, bigger. The displacement is achieved by comparing each pair of contiguous elements from one end to the other. \n To be specific, suppose the bubble is displaced to the left. We can imagine that the vector is divided into two parts, a part already ordered and located on the left and another still disordered located on the right. Initially the ordered left part is empty. For example, let the following vector be: \n
teoriaBurbujaBasica2=\nThe first iteration will "float the bubble" (the smallest element, 1) to the cell to the left. Since the algorithm must achieve this for a vector with any content, two contiguous cells will be successively compared from the extreme right to the left of the vector. As a result, some cells have been shifted to the left from their original position and the smallest element of all, to the extreme left. After this iteration, the ordered part already has one element and the disordered part, the rest. \n
teoriaBurbujaBasica3=\nIn the next iteration, the same comparison process can be done between contiguous cells from the far right to the ordered part. As a result, some cells have been shifted to the left of their original position, and the next smallest element of all, to the right of the ordered vector. After this iteration, the ordered half already has two elements. \n
teoriaBurbujaBasica4=\nThe process described will be repeated until a single element remains in the disordered part, which will be greater than all the others and therefore it will already be ordered. \n
teoriaBurbujaBasica5=\nThe bubble algorithm has a quadratic complexity. Since all the operations it performs are elementary, just look at the different values taken by the indices of the two nested loops. Let n be the length of the vector. The algorithm's time function is equal to: \n
teoriaBurbujaAvanzada1=The optimized bubble algorithm is the same as the bubble algorithm except that, at each iteration, it detects whether there has been any swapping between neighboring cells. If no swapping has occurred, the cells in the vector are already sorted and therefore the algorithm terminates. \n The complexity of the optimized bubble algorithm is equal to the bubble algorithm in worst and middle cases. However, in the best case it has a linear complexity. In effect, in this case the inner loop will iterate without performing any interchange between neighboring cells, after which the algorithm will terminate its execution. Therefore the outer loop terminates. \n
teoriaInsercion1=The direct insert algorithm is, in a way, the inverse of the direct selection algorithm. It performs a sequence of iterations, in such a way that, in each one, it takes the element that is located just after the ordered part of the vector and inserts it in the appropriate place of the already ordered part. \n To be specific, we can imagine that the vector is divided into two parts, a part already ordered located on the left and another still disordered located on the right. Instead of starting from an empty ordered left part, we can start from a left part with an element, since this is also ordered. For example, let the following vector be: \n
teoriaInsercion2=\nThe first iteration takes the element to the right of the ordered part (the 1), which we can call a pivot element. Then, the left part of the vector is traversed from right to left, and each element that is greater than the pivot (in this case, only 8) is shifting one position to the right. This iteration ends when it finds an element on the left less than the pivot or when there are no more elements to compare. The pivot element is then inserted into the position occupied by the last element shifted to its right. \n
teoriaInsercion3=\nIn the next iteration, we take as a pivot the element located to the right of the ordered part (the 7). Again, the left part of the vector is traversed from right to left, shifting each element that is greater than the pivot one position to the right (in this case, 8 again). This iteration ends by finding an element on the left that is smaller than the pivot (1) and inserts the pivot element in the position occupied by the last element shifted to its right (8). After this iteration, the ordered part already has two elements. \n
teoriaInsercion4=\nThe process described will be repeated until the disordered part is empty and therefore the complete vector will be ordered. \n
teoriaInsercion5=\nThe complexity analysis of the direct insertion algorithm is somewhat more complex than that of other algorithms. The inner loop has a compound condition that makes the number of repetitions depend not only on the size of the vector but also on its content. Therefore, a distinction must be made between best, worst and average cases. \n In the best case, the inner loop never executes. Since this cannot happen for the values of the indices, it happens because the second part of the loop condition is not fulfilled, that is, when v[i-1] \u2264 v[i], for 1 \u2264 i \u2264 n-1. This situation occurs when the vector is initially ordered. In this case, the algorithm's time function equals: \n
teoriaInsercion6=\nIn the worst case, the inner loop iterates the maximum number of times allowed by the indices, which requires that the second part of the loop condition always be fulfilled, that is, that v [i-1]> v [i] , for 1 \u2264 i \u2264 n-1. This situation occurs when the vector is initially ordered in reverse order. In this case, the algorithm's time function equals: \n
teoriaInsercion7=\nIn the middle case, the inner loop iterates half the maximum number of times allowed by the indexes. The resulting analysis is similar to that of the worst case, obtaining that T(n) = \u03B8(n\u00B2). \n
teoriaShell1=The Shell algorithm is named after it was invented by Donald Shell in 1959. It is also known as the decreasing ordering algorithm. It is based on the observation that some direct sort algorithms, such as the bubble or insert algorithms, shift small items to the left at the cost of many exchanges because they only compare adjacent cells. Comparing cells located further apart could speed up the sorting. \n The version we present is based on the bubble algorithm and uses increments that are powers of two, with a complexity\nT(n) = \u03B8(n\u00B2). More efficient versions can be obtained from the direct insert algorithm and by using other values for the increments. \n For example, let the following vector, of length 8: \n
teoriaShell2=\nWe start by using an increment equal to half the length of the vector. Therefore, we apply the bubble algorithm to cells whose distance is 4. Only one iteration is performed. \n
teoriaShell3=\nNext, the bubble algorithm is applied again with a size increase half of the previous one, that is 2. This time three iterations are needed, although for this specific vector one is enough to be ordered with increments 2. \n
teoriaShell4=\nNote that the vector is ordered if we compare the cells with increments 2 and 4, but it still needs to be ordered with increment 1. \n Finally, we carry out the same process with increment equal to unity. Although it would take seven iterations in the worst case, the vector is already "fairly ordered", so for this example only three iterations are needed. \n

#PanelVisualizacion
visualizacionRendimiento=Performance:
visualizacionColumnas=Columns 
visualizacionComparaciones=Comparisons 
visualizacionAsignaciones=Assignments
visualizacionComparacion=Comparison
visualizacionAsignacion=Assignment
visualizacionFijados=Final content 
visualizacionNoFijados=Provisional content
visualizacionIncrementos=Increments 
visualizacionIteracion=Iteration 
visualizacionBotonActivar=Activate
visualizacionBotonDesactivar=Deactivate

#MensajesErrorCargar
errorTituloFileNotFound=Error loading file
errorMensajeFileNotFound=The file does not exist
errorTituloIOException=Input/output error
errorMensajeIOException=An error occurred while uploading the file
errorTituloNumberFormat=Input/output error
errorMensajeNumberFormat=The data entered is not valid

#MensajesErrorGuardar
errorExtensionFichero=The file is not in the proper format
errorTituloGuardarFileNotFound=Writing error
errorMensajeGuardarFileNotFound=The file does not exist
errorMensajeIOExceptionGuardar=An error occurred while saving the file
errorTituloIOExceptionGuardar=Input/output error
tituloErrorExtensionImagen=Extension error


#Idioma
idiomaEspanol=Spanish
idiomaIngles=English
idiomaSeleccionMensaje=Select language
idiomaSeleccionTitulo=Language selection
idiomaCambioMensaje=Are you sure you want to change the language?
idiomaCambioTitulo=Change of language

#Visualizacion
tituloVisualizacion=Visualization
encabezamientoVisualizacion=Modify the settings as desired
visualizacionTextoColorAsignacion= Assignment color
visualizacionTextoColorComparacion= Comparisons color
visualizacionTextoColorFijado= Final content color
visualizacionTextoModoOscuro= Dark mode

guardarExito= has been saved correctly
guardarExitoTitulo= Save success
guardarSecuenciaExito= The complete image sequence was saved successfully
guardarAnimacionExito= The full animation was saved successfully

cargarExito= The vector was loaded correctly from the file: 
cargarExitoTitulo= Successful loading

#Animacion
tituloAnimacion=Animation settings
animacionTextoSlider=Select the speed of the animation

#AyudaPanelCodigo
ayudaCodigoTitulo=Help code panel
ayudaCodigoMensaje=In the "Code" tab of the left panel, the lines that are being executed will be underlined

#jFileChooser
#jFileChooser
fileChoserDialogAbrir=Open
fileChoserDialogGuardar=Save
fileChoserMirarEn=Look in
fileChoserAbrir=Open
fileChoserCancelar=Cancel
fileChoserNameLabelText=File name
fileChoserFolderLabelText=Folder name
filesChoserOfTypeLabelText=File type
fileChoseropenButtonToolTipText=Open selected file
fileChosercancelButtonToolTipText=Cancel
fileChoserfileNameHeaderText=File name
fileChoserupFolderToolTipText=Up one level
fileChoserhomeFolderToolTipText=Desktop
fileChosernewFolderToolTipText=Create new folder
fileChoserlistViewButtonToolTipText=List
fileChosernewFolderButtonText=Create new folder
fileChoserrenameFileButtonText=Change file name
fileChoserdeleteFileButtonText=Delete file
fileChoserfilterLabelText=File type
fileChoserdetailsViewButtonToolTipText=Details
fileChoserfileSizeHeaderText=Size
fileChoserfileDateHeaderText=Modify date
fileChoserGuardarEn=Save in
fileChoserGuardar=Save
fileChoserActualizar=Update
fileChoserAyuda=Help
fileChoserToolTip=Save File

#Salir
botonSi=Yes
botonNo=No
textoSalir=Do you want to exit from the application?
tituloSalir=Exit

#InfoPanel
tituloInfo=Information
infoTextoEnunciado=The following have participated in the development of Sortrace:
infoTextoAutor=Author: Eduardo Expósito García
infoTextoTutor=Tutor: Ángel Velázquez Iturbide